## notes (JavaScript refreshers)

### 0:00
Hello. Welcome to secure JavaScript programming with Vladimir de Turckheim. In this video, we will do a few refreshers on JavaScript itself. JavaScript is a programming language that appeared in the late 90s and has become one of the most prominent programming language in the world. In this video, we will go through the basics of JavaScript. You probably know them, but it's never bad to have a few refreshers. Here I've got an ID that is used to write JavaScript code. Let's do a traditional Hello World function call. I just need to write Hello World into a console that logs statement. Here we've got an object named console on it. We've got a function, a method name log and here we can pass a string. I usually close all my statements by semi-colons. Most of the time it doesn't matter and that's a personal preference. I will just write this piece of code and at the bottom of my screen, you can see that we have logged Hello World. When learning JavaScript, one of the first topic, one of the first notion that is easily overlooked is the strict mode. The strict mode is actually a newer feature of JavaScript that has been defined to reduce the weird corner case or cases of the languages. Let's create an object. Here, I've got a new object in the variable x and on the subject, I will define a property that I will name foo. Foo is better name. I will say that its value is 10 and that it's not writable. One could expect that console.logx.foo displays 10. Let's try that. It works. However, if I do x.foo equals 11 and then I console log x.foo once again, it will display 10 twice. That's really weird. Let's understand what happened. The property foo on the x object is not writable. It's not allude to write on it. I wrote on it and I did not get an exception, but the writing was ignored. In theory, in a well-defined language, we should have an exception. That's one of the reason why the strict mode was created. Let's just start use strict as a string at the first-line of our script of function and run that script again. At this point, we've got a type error that is thrown at the line 10. Telling us yes, cannot assign to read only properly foo on object. That is one of the point of the strict mode. It enforces better predictability of the code. As you can see, you can put strict mode at the top of a script or you can put it at the top of a function and in that case, the word script will not be in strict mode. Let's try that. Let's keep our x and create a function. Let's name it the capital F and in this code, we will redefine everything that calls a variable y because it would be ugly otherwise. We rename everything y. We call F below its definition, but here we put use strict. Because that's a lot of flux, we will put some hints to know what we are logging. No, same thing with y and y. Let's rerun everything. At this point, x has been called twice because this piece of code is not in strict mode. So it's allude, it doesn't throw an exception to avail write a known write table part of the code. However, in the function since the function has been defined in strict mode, we cannot have these shootings or foot features. There are a lot of foot features that are different in strict mode and we would see that a bit later in the next part about variables. But as a rule, always run everything in strict mode. That is for historical JavaScript. If you're running JavaScript with ES6 modules which is the module feature of JavaScript. When you've got imports line in your code or exports keywords, you are in a module. For instance, in Node.js, it often happens to have the extension MJS or there will be a type module definition in the package.json. In that case, ES6 modules are all by default in strict mode and you cannot escape it. However out of habit, I usually always put a use strict at the beginning of my scripts. Now, let's talk a bit about variables. Here, I've got a piece of code. Let's remove the use strict as a demo that declares a variables and logs it. But it's a bit weird. There are actually three keywords to declare variables in JavaScript. Historical one is var, and var is somehow a bit weird. It's poorly scoped. When you write var something, it actually compiles to code with the var statement coming at the top of the code. If I run this code, it will work. Let's look at the code. In line 1, we say x equal 10. Then we console.log it, then we define it. It actually doesn't give us any error. Thing is, this code is actually equivalent to this. That because var has this weird behavior, all variables declared with var are actually implicitly declared at the top of the scope. If we use strict this time, it will still work. Even in strict mode, you can use a function, then declare it. However in strict mode, if I remove the var, it will crash as the variable is not defined. If I remove your strict, it will work. The strict mode forces us to declare the variable, but var does not force us to declare the variable before using it. Once again, you should always run in strict mode and avoid var altogether. It has some unpredictable or at least hard-to-understand caveats. One should avoid it altogether. If you can't define variables with var, how can you do it? Well, there are two very handy keywords for that. The first one is named let. Let's do this. This crashes because it tell us cannot access x before initialization. Of course, I'm not using var. I need to declare the functions before I can use them. Also, outside in strict mode once again, you cannot use a viable that you haven't declared. We are in strict mode. We need to declare all the variables with let or const, and we need to declare them before using them with let or const because in this course and in your code, you should always avoid using var or using code outside of strict mode. Let is actually the definition you use when you want to be able to redefine the reference under variable. For instance, if I say x++, it will increment x and they will be able to log two values of it to change its value. However, also, as you can see, I can also declare my variables and initialize it at the same time. This gives exactly the same result. If I use const here, I won't be able to reassign the content of the variable assignment to constant variable. To be fair, x++ is the equivalent of x equals x plus 1. As you can see, my ID complaints.
Play video starting at :10:38 and follow transcript
### 10:38
I wrote some very weird code, Let me rewrite that. With x, I can redefine the variable. With const, it will fail. However, const doesn't mean that the objectives unmutable like in other languages. Let's say I do x equals object and x.foo equals 1. If I console.log x, it will work in some languages. When you use the const keyword, it means that it becomes unmutable. That's not the case in JavaScript. In JavaScript, only the reference, those link from the name of the variable to a value in memory is static with const. However, the value in memory can still be mutated if it's an object, for instance. That's it for the variable part. Now let's talk about something else that is very important, functions. There are multiple ways to define functions in JavaScript. We can start defining a function with the function keyword and a name. In that case, the function will have the same behavior as the var keyword, meaning that its definition will happen at the top of the code. We can also define what we call an anonymous function. It means that you define a function without giving it a name. However for these to be valid, you need to put it in a variable. In that case, the main difference is here, I've got a function object in memory named f. Here I've got a viable pointing to a function that has no name. You can always do what you want in a function and have a scope. If you use constant let within a function, its variables are scoped there, and to return a value out of a function, you use the return keyword. There is another way to define function, it's arrow function. Arrow equals e, and arrow functions can have, for instance, a short way of returning. This is the equivalent of return. This is the same two functions Arrow 1 and Arrow 2, do the same thing, they return that time once. That's not really interesting. However, there is one last way of defining function, and this one is actually problematic in term of security most of the time.
Play video starting at :13:43 and follow transcript
### 13:43
A new function equals new function, and here you need to declare the variables a, b, and here the code of the function a, b.
Play video starting at :14:10 and follow transcript
### 14:10
At this point if I can console.log a new function, that two string, we will see the source code of the function defined with the function constructor. You see it's a function that takes two arguments and returns a plus b. It's pretty dangerous to use this syntax because you can create vulnerabilities to string injections, and you don't want that. You always declare your function properly with the right keywords. Javascript objects are typed and there are a few basic types in JavaScript. Even if variables are not types, you can check the type of something using some type of keyword. Let's do a few things. Let's put a few items.
Play video starting at :15:14 and follow transcript
### 15:14
Here we've got the type of different values, the type of an object is object, the type of a number is a number, the type of a string is a string, the type of a number isn't another member, so type buffers new is object that the usual caveats when you try something for being an object, you also need to try if it's new, and the type of undefined is undefined. Undefined value in JavaScript is the value of something of a variable that has not been initialized of a function as a return value of a function that doesn't have a return value, or a functions, a variable that just doesn't exist or property on an object that does not exist. The last important part of JavaScript to it, since this video is the equality and the falsy values. In JavaScript, you've got two ways of testing equalities, you've got double equals, and you've got triple equals. If I run 1 double equals string 1, it returns true, but tripled equal string ones return false. That's because double equals does not enforce type checking. Meanings are two variables that have somehow, the same content, two values, we suppose have the same content, might be equal with w equals. That's why we always must use triple equal in JavaScript to enforce type checking in viable comparison. Also, JavaScript as a set of values that are falsy. To test if something is truthy or falsy, you use double bank. Then you can test a value for being falsy. The least of value being falsy in JavaScript is pretty interesting. Here is the full one. Let's run it to check and everything logs false. False obviously is falsy, zero is falsy, I can see. The empty string is falsy, the new value is falsy, the undefined value is falsy, and the not number of value, which is a number, return when you try a numeric operation or some things that is not a number is also falsy. All of that can be found in falsy checkings, and can also shoot you in the foot. Those are my personal list of good chaff javascript that I wanted to review with you before going further in the secure JavaScript programming course. I hope you address this first video, and I hope to see you soon in another video. Until then, have a great day.
