## notes (VideoWeb browser refreshers)

### 0:00
Hello. Welcome to secure JavaScript programming with Vladimir de Turckheim. In this video, we will do some refreshers about the web browser. Let me just remove Slack and we can start. Here we've got a pretty simple, straightforward web page. Actually, I know it's not very usual nowadays, but if we check the source code of the page, we actually have the real content of the page. With modern frameworks such as Angular or React, this doesn't happen much anymore. This is a very standard HTML page with two paragraphs. One, which had ID1 and one which has a class 1 and the first one contains P1 and the second one contains P2. The web browser is one of the two main JavaScript runtime environment. The other being Node.js that we will see in another video. It's the historical one and pretty much all desktop computer in the world use web browsers. It is extremely important to understand to where browser is. Basically, it is made of two components. An engine that renders the HTML page, this is the one that actually displays what is in the HTML code and a JavaScript engine. The JavaScript engine executes the JavaScript code. For instance, in the case of Chrome. JavaScript engine is named V8 and that's an open source Google project. You can get standalone V8 and it's also used by Node.js. There are other JavaScript engine, for instance, the one that is built by the multi-year foundation is named spider monkey and is used by the very popular MongoDB database. The JavaScript engine has what it's called bindings. Meaning that some object and functions are provided by the environment to expand what you can do with JavaScript. Instead of just being able to write code, so for instance, we will do a console.log hello world. This is just plain JavaScript code as we could run in any other JavaScript environment. You can also interact with the document object model with the web page. Let's say I want to access to the paragraph which contains P1. Then we can call the document object that is provided by the browser, choose JavaScript engine, and we would say getElementsById. Meaning we will get one single element by its ID. Because in the HTML specification, there should be only one element in a page with the same ID. Here we just put ID1. That's the string and it returns us with the document. It's a pretty view that we have to see it but under the hood, if we get out of the console,
Play video starting at :4:4 and follow transcript
### 4:04
let me just clear the console, we can just get it and put it in a variable. So const p1 equals. Here we've got a value in P1, which is a paragraph, but we can also access it's constructor. Here it's in JavaScript and we see it implements a class named HTML paragraph element. This class actually implements another class, which is named HTML elements. The HTML element class defines all the methods that are accessible on the elements that exist in HTML. Because there are bindings between the JavaScript and the HTML world, it is possible to actually change what is in the HTML page from JavaScript. Let's take our p1 and change the inner text to Hello World.
Play video starting at :5:19 and follow transcript
### 5:19
If you look at the left-hand side of the screen, when a press Enter, the value of p1, the text within the variable, has changed. If we check the source, it hasn't changed in the source itself but it has changed in the representation, in the living document. If I reload the page, I go back to the previous item. Now, let's get document.getElementsByClassName, and let's do class1. Here, we've got an HTMLCollection, it's not an array, but it's an iterable object. This means that you can call a for loop on it, but you can also call Array, sorry, let me start it again. Here I've got this one, Array.from,
Play video starting at :6:22 and follow transcript
### 6:22
and from all iterable, you can call Array.from and it will return you an array. Each element inside is actually an HTML element. We can do the same things. But they are not arrays when you get them from the top, you need to convert them. Also, there are other APIs that are available. There are APIs to access the webcam of the user that will print a need for the user to explicitly accept the website to use the webcam. But you can also access the GPU or the USB port. So web browser is no more like an operating system than just a web browser. You can access the hardware. You can also create workers. Workers will be all the threads that will run in parallel from your web page. Also, it's worth noticing that two tabs in the web browser are technically isolated, you cannot check, communicate with another tab directly. If they are from the same domain, they can share the same worker, and you can't communicate through tabs through a third-party thread. Browsers also have ways to do HTTP calls over JavaScript calls. For instance, there is the fetch method. Let's try to call example.com. It returns a Promise and it tells us that something went wrong. Two things happened: first of all, we created a pending Promise and at one point it got rejected. Why did it get rejected? Because of the C-O-R-S, usually named CORS, which are a feature that prevents websites from accessing from multiple regions. We will see, later in this course, about attacks through web browsers. For instance, since this website is running on my own machine, if I allow it to access any resource, I could use it, if compromised, to load assets from somewhere else and get and access this. But we will see that later in another video. Since web browsers have network access, they have the same network's capability as the host machine. They can usually access the Internet to load web pages. But if you've got a local network, which is our home network or enterprise network, our web browser can access any documents, fire system, websites on these other networks. Often, we can see attacks of malicious websites that are trying to access enterprise, our home networks, through web browsers. Web browsers, when they run a website, they provide with development tools. You can, for instance, take a snapshot of the JavaScript memory of the code of a web page. Here, we have access to the whole memory of the web page, nothing under the server, everything in the browser. You can also get CPU profile to debug your website or reverse how it works. You even have a security tab to check whether the security issues, for instance, this web page has been loaded through HTTP instead of HTTPS, meaning that the assets can might have been tempered by a man-in-the-middle attack or are just not authenticated. Since we are localist and it's working properly on their machine, we are good to go. But a non-HTTPS website may be dangerous. In the application tab, you can see that the web browser provide what are called Storages. These are multiple carriers of storage, the local storage that are proper to the websites. You've got session Storages that are cleaned each access to the website. The local storage is not, It's a cache that exist until it's cleaned. You've got two databases, one of them is actually outdated. You can learn on them directly on Google's website. You've got cookies. Cookies are set-based server and are either accessible in JavaScript or not, depending on how they work. You can push data from a server to the browser with certain API, and you've got a lot of other new API in modern web browsers. If your application has a manifest, it can be held as a web application that would be the equivalent of a mobile application, but within the browser. I was talking earlier about workers. You've got web workers, but also service workers that can be used to perform tasks on your browser way then when the website is not runnimg in the foreground. Also, you can see that I have extensions, such as AdBlock. Extensions are usually written in JavaScript and have access to certain authorization. For instance, the AdBlock extension on my browser is allowed to check where to prevent the web pages from loading assets from certain origins. That can be extremely intrusive, so one should know exactly whether the authorization of each extensions they run JavaScript. That's not only websites that run Java script, but also extensions. I've got an extension that I like a lot that is named Wappalyzer. Let's go to google.com.
Play video starting at :13:11 and follow transcript
### 13:11
Here, if I click on this, it tells me that it's running on Google web servers, use of JavaScript library name Hammer.js and has Cart Functionalities. That's an extension that I have a load to audit my web traffic to see what are the technologies used by the websites I connect to. Here, you can see that it has detected items through AdBlock and allow me to block them, and that's just JavaScript code. We've got some errors that are the one from our earlier fetch. What did we learn? We learned that the browser is probably one of the most dangerous piece of code to run on your laptop or your desktop machine. Because you are an arbitrary code that comes from the Internet without deciding to run it because nobody disables JavaScript execution anymore. That can ask to access your hardware directly. That can perform network access on local network or remote network, and the browsers can actually load multi-threats and run app extension that can spy on your traffic on the Internet. In this course, we will go in depth against the attacks regarding browser JavaScript and server site JavaScript. But it's important to understand these core concepts about the web browsers. That's it for this video about refreshers on the web browsers. I hope you enjoyed it and it refreshed a few concepts that are much needed, namely bindings, code execution, and page rendering. Thanks a lot for watching this video. Have a great time until we meet again.
0:00 Hello. Welcome to secure JavaScript programming with Vladimir de Turckheim. In this video, we will do some refreshers about the web browser. Let me just remove Slack and we can start. Here we've got a pretty simple, straightforward web page. Actually, I know it's not very usual nowadays, but if we check the source code of the page, we actually have the real content of the page. With modern frameworks such as Angular or React, this doesn't happen much anymore. This is a very standard HTML page with two paragraphs. One, which had ID1 and one which has a class 1 and the first one contains P1 and the second one contains P2. The web browser is one of the two main JavaScript runtime environment. The other being Node.js that we will see in another video. It's the historical one and pretty much all desktop computer in the world use web browsers. It is extremely important to understand to where browser is. Basically, it is made of two components. An engine that renders the HTML page, this is the one that actually displays what is in the HTML code and a JavaScript engine. The JavaScript engine executes the JavaScript code. For instance, in the case of Chrome. JavaScript engine is named V8 and that's an open source Google project. You can get standalone V8 and it's also used by Node.js. There are other JavaScript engine, for instance, the one that is built by the multi-year foundation is named spider monkey and is used by the very popular MongoDB database. The JavaScript engine has what it's called bindings. Meaning that some object and functions are provided by the environment to expand what you can do with JavaScript. Instead of just being able to write code, so for instance, we will do a console.log hello world. This is just plain JavaScript code as we could run in any other JavaScript environment. You can also interact with the document object model with the web page. Let's say I want to access to the paragraph which contains P1. Then we can call the document object that is provided by the browser, choose JavaScript engine, and we would say getElementsById. Meaning we will get one single element by its ID. Because in the HTML specification, there should be only one element in a page with the same ID. Here we just put ID1. That's the string and it returns us with the document. It's a pretty view that we have to see it but under the hood, if we get out of the console, Play video starting at :4:4 and follow transcript4:04 let me just clear the console, we can just get it and put it in a variable. So const p1 equals. Here we've got a value in P1, which is a paragraph, but we can also access it's constructor. Here it's in JavaScript and we see it implements a class named HTML paragraph element. This class actually implements another class, which is named HTML elements. The HTML element class defines all the methods that are accessible on the elements that exist in HTML. Because there are bindings between the JavaScript and the HTML world, it is possible to actually change what is in the HTML page from JavaScript. Let's take our p1 and change the inner text to Hello World. Play video starting at :5:19 and follow transcript5:19 If you look at the left-hand side of the screen, when a press Enter, the value of p1, the text within the variable, has changed. If we check the source, it hasn't changed in the source itself but it has changed in the representation, in the living document. If I reload the page, I go back to the previous item. Now, let's get document.getElementsByClassName, and let's do class1. Here, we've got an HTMLCollection, it's not an array, but it's an iterable object. This means that you can call a for loop on it, but you can also call Array, sorry, let me start it again. Here I've got this one, Array.from, Play video starting at :6:22 and follow transcript6:22 and from all iterable, you can call Array.from and it will return you an array. Each element inside is actually an HTML element. We can do the same things. But they are not arrays when you get them from the top, you need to convert them. Also, there are other APIs that are available. There are APIs to access the webcam of the user that will print a need for the user to explicitly accept the website to use the webcam. But you can also access the GPU or the USB port. So web browser is no more like an operating system than just a web browser. You can access the hardware. You can also create workers. Workers will be all the threads that will run in parallel from your web page. Also, it's worth noticing that two tabs in the web browser are technically isolated, you cannot check, communicate with another tab directly. If they are from the same domain, they can share the same worker, and you can't communicate through tabs through a third-party thread. Browsers also have ways to do HTTP calls over JavaScript calls. For instance, there is the fetch method. Let's try to call example.com. It returns a Promise and it tells us that something went wrong. Two things happened: first of all, we created a pending Promise and at one point it got rejected. Why did it get rejected? Because of the C-O-R-S, usually named CORS, which are a feature that prevents websites from accessing from multiple regions. We will see, later in this course, about attacks through web browsers. For instance, since this website is running on my own machine, if I allow it to access any resource, I could use it, if compromised, to load assets from somewhere else and get and access this. But we will see that later in another video. Since web browsers have network access, they have the same network's capability as the host machine. They can usually access the Internet to load web pages. But if you've got a local network, which is our home network or enterprise network, our web browser can access any documents, fire system, websites on these other networks. Often, we can see attacks of malicious websites that are trying to access enterprise, our home networks, through web browsers. Web browsers, when they run a website, they provide with development tools. You can, for instance, take a snapshot of the JavaScript memory of the code of a web page. Here, we have access to the whole memory of the web page, nothing under the server, everything in the browser. You can also get CPU profile to debug your website or reverse how it works. You even have a security tab to check whether the security issues, for instance, this web page has been loaded through HTTP instead of HTTPS, meaning that the assets can might have been tempered by a man-in-the-middle attack or are just not authenticated. Since we are localist and it's working properly on their machine, we are good to go. But a non-HTTPS website may be dangerous. In the application tab, you can see that the web browser provide what are called Storages. These are multiple carriers of storage, the local storage that are proper to the websites. You've got session Storages that are cleaned each access to the website. The local storage is not, It's a cache that exist until it's cleaned. You've got two databases, one of them is actually outdated. You can learn on them directly on Google's website. You've got cookies. Cookies are set-based server and are either accessible in JavaScript or not, depending on how they work. You can push data from a server to the browser with certain API, and you've got a lot of other new API in modern web browsers. If your application has a manifest, it can be held as a web application that would be the equivalent of a mobile application, but within the browser. I was talking earlier about workers. You've got web workers, but also service workers that can be used to perform tasks on your browser way then when the website is not runnimg in the foreground. Also, you can see that I have extensions, such as AdBlock. Extensions are usually written in JavaScript and have access to certain authorization. For instance, the AdBlock extension on my browser is allowed to check where to prevent the web pages from loading assets from certain origins. That can be extremely intrusive, so one should know exactly whether the authorization of each extensions they run JavaScript. That's not only websites that run Java script, but also extensions. I've got an extension that I like a lot that is named Wappalyzer. Let's go to google.com. Play video starting at :13:11 and follow transcript13:11 Here, if I click on this, it tells me that it's running on Google web servers, use of JavaScript library name Hammer.js and has Cart Functionalities. That's an extension that I have a load to audit my web traffic to see what are the technologies used by the websites I connect to. Here, you can see that it has detected items through AdBlock and allow me to block them, and that's just JavaScript code. We've got some errors that are the one from our earlier fetch. What did we learn? We learned that the browser is probably one of the most dangerous piece of code to run on your laptop or your desktop machine. Because you are an arbitrary code that comes from the Internet without deciding to run it because nobody disables JavaScript execution anymore. That can ask to access your hardware directly. That can perform network access on local network or remote network, and the browsers can actually load multi-threats and run app extension that can spy on your traffic on the Internet. In this course, we will go in depth against the attacks regarding browser JavaScript and server site JavaScript. But it's important to understand these core concepts about the web browsers. That's it for this video about refreshers on the web browsers. I hope you enjoyed it and it refreshed a few concepts that are much needed, namely bindings, code execution, and page rendering. Thanks a lot for watching this video. Have a great time until we meet again.: Added to Selection. Press [CTRL + S] to save as a note
