تازه‌سازی‌ها در احراز هویت وب
0:03
سلام، و به برنامه نویسی جاوا اسکریپت ایمن با Vladimir de Turckheim خوش آمدید. من ولادیمیر د تورکهایم هستم، من مهندس اصلی یک استارت آپ به نام Sqreen هستم، جایی که ما امنیت وب را انجام می دهیم. و من همچنین عضو تیم کروم Node.js هستم، چند سالی است که node.js کروم دارم. شما می توانید من را در توییتر دنبال کنید، در واقع این روش ترجیحی من برای تماس از طریق اینترنت است. بنابراین اگر می‌خواهید مستقیماً با شما ارتباط برقرار کنید، این کار را از طریق حساب توییتر من انجام دهید، این @poledesfetes است. بنابراین در این دوره ما در مورد احراز هویت و جریانات و واژگان مرتبط با احراز هویت صحبت خواهیم کرد. و البته ما بیشتر بر روی برنامه های کاربردی وب تمرکز خواهیم کرد. بنابراین ابتدا آنچه که احراز هویت است، احراز هویت عمل دانستن اینکه مشتری فعلی کیست و می‌تواند چندین نوع کلاینت در یک جریان احراز هویت وجود داشته باشد. این می تواند یک انسان باشد، یک کاربر واقعی. بنابراین شما می خواهید شناسایی کنید که انسان آن طرف شبکه چه کسی است. ممکن است دستگاهی وجود داشته باشد که بخواهید تشخیص دهید که یک تلفن یا رایانه ای است که این عملیات را انجام می دهد. اگر مشتری من یک دستگاه یا شاید یک نرم‌افزار است، می‌خواهید یک نرم‌افزار مانند مرورگر وب را شناسایی کنید یا اگر یک سرور مجوز دارید، به عنوان یک نرم‌افزار در طرف دیگر شبکه شناسایی می‌کنید. و این تقریباً ایده احراز هویت است، شما می خواهید شناسایی کنید که مشتری چه کسی است. اما بسته به زمینه، آنها می توانند انواع مختلفی از موجودیت ها باشند. وقتی می‌خواهید مشتری را شناسایی کنید، معمولاً کاری را انجام می‌دهید که عملیات ورود نامیده می‌شود، عمل ورود به سیستم و آن عمل شناسایی مشتری بر اساس اسرار مشترک. اسرار یا ویژگی های متعدد، بنابراین شما راه های متعددی برای انجام آن دارید. و معمولاً هنگامی که ورود را انجام دادید، چیزی را ایجاد می‌کنید که یک جلسه نامیده می‌شود، که در جانبی است. بنابراین شما راه های متعددی برای شناسایی شخصی با راز دارید. یا شما راز را به اشتراک گذاشته اید و این واقعاً قوی نیست زیرا اگر کسی را شناسایی کنم، فقط باید رمز عبوری را بدانم که هر دو می دانیم. افراد زیادی هستند که این گذرواژه ها را می دانند، بنابراین احتمالاً برای فیلم های جاسوسی خوب است اما واقعاً در اینترنت و شبکه ها امکان پذیر نیست. می توانید از یک نام کاربری / رمز عبور استفاده کنید. در این صورت باید رمز عبور را هش کنید، بنابراین رمز عبور در سایت سرور را نمی دانید و فقط مشتری رمز عبور را می داند که در کنار آن قرار دارد. می‌توانید از OTP برای گذرواژه‌های یک‌بار مصرف استفاده کنید، این رمز عبوری است که از طریق پیام متنی یا در یک برنامه احراز هویت در تلفن همراه خود دریافت می‌کنید. در این مورد من به شما توصیه می کنم از یک ارائه دهنده شخص ثالث استفاده کنید زیرا مشخصات ساخت سیستم های OTP در واقع بسیار پیچیده است. یک RFC برای آن وجود دارد و واقعاً پیچیده است و اشتباه کردن و کاهش سطح امنیتی سیستم جهانی واقعاً آسان است. بنابراین توصیه می‌کنم که خودتان را نچرخانید. این حداقل ورود به سیستم شخص ثالث ما بوده است، برای مثال لاگین های اجتماعی ما، جایی که شما از طریق گوگل وارد می شوید یا از طریق فیس بوک وارد سیستم می شوید. خوب، شما به شخص ثالثی برای کنترل احراز هویت کاربر متکی هستید. شما همچنین می توانید نهادهای تجاری داشته باشید، این همان چیزی است که کسب و کار از آن برای انجام احراز هویت و مدیریت کاربر برای شما استفاده می کند، یکی از آنها برای مثال Auth0. خب لاگین معمولا گاهی اتفاق می افتد، شما هر روز به آدرس ایمیل جیمیل خود وارد نمی شوید. شما مرورگرهای خود را دارید که در مقابل آن احراز هویت شده است و معمولاً کاربر نهایی از آن آگاه است زیرا یک اقدام کاربر وجود دارد. اگر رمز عبور برای نوشتن وجود دارد، کاربر باید رمز عبور را بنویسد. اگر رمزهای یکبار مصرف وجود دارد، باید آن را در تلفن خود دریافت کنند. اگر این یک ورود شخص ثالث است، خوب آنها باید روی ورود با شخص ثالث کلیک کنند. بنابراین کاربر نهایی انسان است که معمولاً از این عملیات آگاه است. هنگامی که آنچه در طرف دیگر وجود دارد را شناسایی کردید، می توانید یک جلسه ایجاد کنید. و جلسه، برای شناسایی مشتری شما است که قبلاً وارد شده است. راه های متعددی برای حفظ یک جلسه وجود دارد و اساساً ایده این است که برای هر درخواست HTTP شما بتوانید بدون اینکه درخواستی برای مشتری داشته باشید، بدانید چه چیزی با مشتری در طرف دیگر است. کاربر نهایی برای نوشتن رمز عبور برای هر درخواست HTTP. بنابراین چندین فناوری وجود دارد و در مورد ورود، می توانید همزمان از بیش از یک استفاده کنید. بنابراین، برای مثال، یکی از محبوب ترین آنها کوکی ها هستند. لطفاً فقط آنها را روی HTTP قرار دهید و آنها را در دسترس قرار ندهید. برای کد جاوا اسکریپت، توکن های وب JSON یا JWT را دارید. توکن JWT را نگویید زیرا مخفف JSON web token token است و واقعاً معنایی ندارد و این اشتباهی است که بسیاری از مردم انجام می دهند. بنابراین، برای مثال، رمز وب JSON، من دو داده را به صورت امضا شده وزن خواهم کرد. بنابراین می‌دانید چه کسی توکن را صادر کرده است، زیرا امضا شده است و با کلید عمومی، می‌توانید بررسی کنید که توسط مرجعی که انتظار دارید آن را امضا کند، امضا شده است. اما استفاده از JWT به عنوان یک کوکی می تواند منطقی باشد، هیچ چیزی مانع آن نمی شود، این در واقع بسیار رایج است. یا فقط می توانید یک رشته تصادفی ایجاد کنید، آن را امضا کنید تا مطمئن شوید که توسط مرجع مورد اعتماد شما صادر شده است و آن را در یک کوک قرار دهید.

کیه این کاملاً کار می کند، و این معمول ترین راه برای احراز هویت یک کاربر در اینترنت است. کاربر نهایی در مورد آن چیزی نمی داند زیرا زیر کاپوت است. زیرا در صورت درخواست HTTP کوکی که در مرورگر است به سرور بازگردانده می شود و سرور با کوکی و حساب کاربری در پایگاه داده نقشه برداری می کند. بنابراین چند روش برتر در اینجا، این کار را فقط از طریق HTTPS انجام دهید. این کار را از طریق HTTP انجام ندهید زیرا اگر رمزگذاری در راه نباشد، هر کسی می تواند یک جلسه را بدزدد. همچنین باید جلسات را منقضی کنید، در یک نقطه یک جلسه نمی تواند برای همیشه معتبر باشد و باید جلسه را باطل کنید. بنابراین اگر شخصی از سیستم خارج شود، از سرویس خارج شود، باید مطمئن شوید که کوکی، رمز دیگر معتبر نیست و در هر درخواست از احراز هویت خودداری می کند. این یک اشتباه بسیار رایج وب است که فراموش می کند جلسات را باطل کند. خوب در مورد خروج از سیستم، خروج از سیستم عمل بستن یک ایستگاه است. بنابراین باید آن را باطل کنید، باید انجام شود. یک بار دیگر، این یک اشتباه بسیار رایج است. همه به دلایلی خروج از سیستم را فراموش می کنند. گاهی اوقات منطقی است که از برنامه خارج شوید، حتی در یک برنامه تلفن همراه و این یک انتخاب پروژه است، باید با تجربه کاربری برای برنامه شما مطابقت داشته باشد. معمولاً می خواهید کاربر از آن آگاه باشد، بنابراین آنها به طور فعال از سیستم خارج می شوند. بنابراین، برای مثال، اگر سوابق بانکی خود را به صورت آنلاین بررسی می کنید، می خواهید مطمئن شوید که قبل از اینکه دیگران بتوانند از همان مرورگر استفاده کنند، از سیستم خارج شده اید. یا حتی می‌خواهید برای بی‌اعتبار کردن تصمیم خود از سیستم خارج شوید، بنابراین اگر کسی بتواند کوکی‌های شما را در گزارش پیدا کند، نمی‌تواند آن را دوباره پخش کند. به همین دلیل بسیار مهم است که از سوابق بانکی خود به صورت آنلاین خارج شوید. با این حال، این امکان وجود دارد که تصمیم فقط باطل شده باشد، منقضی شده باشد، و اگر منقضی شده باشد، خوب، شما بی سر و صدا از سیستم خارج شده اید و زمانی که باید دوباره وارد شوید متوجه خواهید شد. مجوز، مجوز زمانی اتفاق می افتد که مشتری سعی می کند به یک منبع دسترسی پیدا کند. و هنگامی که سعی می کنید به یک منبع دسترسی پیدا کنید، باید مطمئن شوید که مشتری حق دسترسی به این منبع را دارد. بنابراین می تواند چندین سطح از مجوز وجود داشته باشد. به عنوان مثال، اگر سیستمی دارید که به راحتی پر است، بهتر است فقط برای کاربران احراز هویت شده باشد. فقط باید بررسی کنید که آیا کاربر احراز هویت شده است یا خیر و کافی است. اما اگر این یک رکورد شخصی است، بیایید بگوییم که در آن مدرسه نمره دانش آموز را نگه می دارد. شما دانش آموز A را مجبور به دسترسی به نمره دانش آموز B نمی کنید. بنابراین این دانش آموز وجود دارد، آیا منبع حاوی داده ها نباید برای این مشتریان ارسال شود، این سومین نکته در اینجا است. همچنین سوال نقش وجود دارد، اگر شما یک مدیر سیستم هستید، شاید به تمام داده های داخل سیستم دسترسی داشته باشید. بنابراین یک سوال در مورد احراز هویت مالکیت منبع و حقوق به عنوان دسترسی مبتنی بر نقش وجود دارد. در جایی که ادمین به همه چیز دسترسی دارد، ناظم می‌تواند داده‌ها را تعدیل کند و افراد می‌توانند آنطور که برای کاربران عادی منطقی است به داده‌ها دسترسی داشته باشند. بنابراین دسترسی مبتنی بر محتوا بسیار مهم است زیرا در دنیای مبتنی بر GDPR و CPA، محتوای یک منبع ممکن است بسیار حساس باشد. به عنوان مثال، اگر شماره تامین اجتماعی یا موجودی حساب بانکی در سیستم خود دارید. شما باید مطمئن شوید که کاربری که به آن دسترسی دارد حق دسترسی به آن را دارد. شاید برخی از کارکنان بانک نباید به شماره تامین اجتماعی برخی از مشتریان دسترسی داشته باشند. بنابراین هنگام واکشی منبع، باید بدانید که آیا PII، که اطلاعات هویتی شخصی یک فرد است، توسط مشتری او قابل دسترسی است یا خیر. این نیازهای GDPR است. به عنوان مثال، شخصی که بسته ها را تحویل می دهد نباید مستقیماً به شماره تلفن مشتریان دسترسی داشته باشد. این باید از طریق یک سرویس مرکزی که ناشناس بودن شماره تلفن را برای هر دو طرف تضمین می کند انجام شود زیرا یک خیابان دو طرفه است. اگر شخصی بسته ای را به شما تحویل دهد، نباید به شماره تلفن شخصی شخص تحویل دهنده دسترسی داشته باشید. و اگر تاریخچه برنامه های اشتراک گذاری خودرو را بررسی کنید. موارد زیادی وجود داشته است که راننده با داشتن اطلاعات شناسایی شخصی در مورد مسافران می تواند منجر به مشکلاتی شود. و به همین دلیل است که باید ناشناس بودن بین آن دو طرف را تضمین کنید. بنابراین PII های خود را بررسی کنید، این یکی از مهم ترین بخش ها است. بیایید به قسمت آخر این دوره برویم، که رمزنگاری برای توسعه دهندگان مشغول است. این به هیچ وجه در مورد رمزنگاری نیست، بلکه بیشتر درباره اینکه چه اصولی از مفاهیم رمزنگاری باید توسط هر کسی که برنامه‌های کاربردی وب می‌سازد بداند، بیشتر است. بنابراین، توابع هش کردن، من دوست دارم بگویم چگونه می توان یک راز را بدون دانستن آن بررسی کرد. توابع هش رمز عبور برای بررسی رمزهای عبور بدون فروش آنها در متن ساده استفاده می شود. در اصل، شما یک رشته به عنوان ورودی به این تابع می دهید. هر چه که فرود بیاید و رشته ای با طول ثابت برمی گرداند و تضمین می کند که پیدا کردن دو خروجی با خروجی یکسان واقعاً سخت است. بنابراین شما یک پارامتر را پاس می کنید، یک پاسخ و خروجی دریافت می کنید. و یافتن ورودی و یافتن ورودی که همان خروجی را به شما می دهد از خروجی بسیار سخت است. چگونه تابع هش مناسب را انتخاب می کنید؟ خوب، من توصیه می کنم با آن چک کنید

موسسه ملی استاندارد و فناوری، NIST توصیه می کند. زیرا این با گذشت زمان به عنوان دانش و حملات علیه این عملکردها تکامل می یابد. بنابراین برای به روز بودن، آنچه را که NIST توصیه می کند بررسی کنید. همچنین حتماً از نمک استفاده کنید تا از حملاتی که می‌تواند حملات زمانی یا حمله‌های رنگین کمانی باشد، اجتناب کنید. و با خیال راحت در گوگل جستجو کنید که چیست، اما این یک دوره آموزشی در مورد حمله به رمزنگاری نیست، بنابراین من به آن عمق نمی‌دهم. معمولا bcrypt یک شرط بندی مطمئن است. رمزنگاری متقارن، یک کلید خصوصی وجود دارد و هر دو طرف آن را می دانند. بنابراین زمانی که یک راز مشترک دارید، تنها یک راز وجود دارد و می توان از آن برای رمزگذاری و رمزگشایی پیام استفاده کرد. بنابراین شما یک پیام دارید، از کلید استفاده کرده اید، می توانید آن را رمزگذاری کنید و از همان کلید استفاده می کنید، می توانید آن را رمزگشایی کنید. این معمولاً از نظر عملکرد بسیار خوب است و الگوریتم استاندارد در حال حاضر برای آن AES است، الگوریتم بسیار خوبی برای آن است. از یک کلید خصوصی استفاده می کند، اما یک الگوریتم وبلاگ است، بنابراین می تواند به حملات خاصی علیه آن منجر شود. ویکی‌پدیا واقعاً خوب است که آنها را توضیح دهد. بنابراین هنگامی که از آن استفاده می کنید، از یک حالت عملیاتی استفاده کنید تا آن را به یک الگوریتم جریان تبدیل کنید که در آن حمله بلوکی نمی تواند اتفاق بیفتد. از طرف دیگر رمزنگاری نامتقارن ابزار بسیار جالبی است. شما یک کلید خصوصی دارید، این یک راز است که توسط یک نهاد واحد شناخته شده است و یک کلید عمومی وجود دارد که همه در جهان می توانند آن را بدانند. و اگر پیام را با کلید عمومی رمزگذاری کنید، تنها شخصی که به کلید خصوصی دسترسی دارد می‌تواند آن را رمزگشایی کند. همچنین می توانید از کلید خصوصی برای امضای یک پیام استفاده کنید و در آن کلید همه افرادی که کلید عمومی را دارند می توانند مطمئن شوند که پیام با استفاده از آن کلید خصوصی امضا شده است. بنابراین این امضا است زیرا شما می توانید نویسنده این امضا را شناسایی کنید. یکی از محبوب ترین رمزنگاری نامتقارن RSA است، شما همچنین BGP دارید. به طور کلی و این احتمالا یکی از مهم ترین اسلایدها در این ارائه جهانی است، هرگز رمزنگاری خود را رول نکنید. بنابراین الگوریتم های رمزنگاری بی شماری وجود دارد که پیاده سازی برخی از آنها واقعاً پیچیده است. اجرای اکثر آنها واقعاً پیچیده است. و ما را به اجرای رمزنگاری برنگردانید. همیشه به کسی اجازه دهید این کار را برای شما انجام دهد زیرا انجام این کار واقعاً سخت است و شکست خوردن آن بسیار آسان است. از تماشای این ارائه بسیار سپاسگزارم. امیدوارم به زودی شما را در ارائه دیگری درباره برنامه نویسی امن جاوا اسکریپت ببینم. تا آن زمان، روز خوبی داشته باشید و مراقب باشید.
